\chapter{Proving invariants in the deep embedding} \label{Work}
In this section, we show how we proved three different invariants of PIP. The companion code can be found at \url{https://github.com/CherifSami/coq_internship}. The first invariant is about a function that reads the memory. The second one is about a function that writes in the memory. The last invariant is about a recursive function. We explain throughout this section our approach in modelling these functions and the way we engineered our proofs while trying to make them modular and as simple as possible. The first section is dedicated to a briefing on the preliminary work we did to become more familiar with the deep embedding and the Hoare logic we built on progressively. In the second section, we explain how we modelled the PIP monad by replicating the PIP state. In later sections we show how we modelled the shallow functions and proved their invariants in the deep embedding. The last section is dedicated to our observations on the difference between shallow and deep proof as well as the limitations imposed on our verification proofs by the DEC language. 

\section{Preliminary experiments}
For this preliminary work, we used an untyped form of the Hoare logic triple which was later refined to the one we defined in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec}. We started working with a natural number state on which we defined two functions. The first function called \textit{ReadN} simply reads the current value of the state while the second one called \textit{WriteN} writes a given value in the state. To model these functions, we used generic effects since they act directly on the state. We proved several Hoare triple rules about these functions. For instance, we proved that if we write a value x in the state then read it immediately after, we should get the same value x. This is quite similar to an invariant we proved on the PIP state, called  \textit{writeVirtualInvNewProp}, which is  detailed in section \ref{writeInvSec} p.\pageref{writeInvSec}. Then, we switched to an association list state which resembles more the PIP state. We also devised shallow reading and writing functions on this state as the ones defined on the PIP state in annex \ref{LibFile} p.\pageref{LibFile}. We used these functions to define deep reading and writing functions on such state using generic effects. Then we proved similar lemmas to the one we did on the natural number state. 
 
\section{Modelling the PIP monad in the deep embedding}
To prove invariants of PIP in the deep embedding, it is essential to replicate the PIP memory state specified in the PIP monad, defined in script \ref{monad} p.\pageref{monad}. To that end, all type definitions mentioned in section \ref{PIPstateSection} p.\pageref{PIPstateSection} are copied in the file \textit{PIP\_state.v}. All the axioms, constructors, comparison functions as well as predefined values were also copied in this file as shown in annex \ref{stateFile} p.\pageref{stateFile}. Then, we defined a module of type \textit{IdModType}, detailed in annex \ref{ModType} p.\pageref{ModType}, where the type parameter \textit{W} is set to the PIP \textit{state} record type, defined in script \ref{PIPstate} p.\pageref{PIPstate}. We defined the initial value of this type parameter which corresponding to an empty memory. Furthermore, The \textit{Id} type parameter for identifiers is set to \textit{string}. This module, called \textit{IdModP}, will be passed as a parameter to the modules we're going to work on later. It is defined in the the file \textit{IdModPip.v} as follows :
\begin{lstlisting}[caption = {PIP state in the deep embedding}, xleftmargin=.1\textwidth,
xrightmargin=.1\textwidth]
Require Import Pip_state.

Module IdModP <: IdModType.
  Definition Id := string.
  
  Definition W := state.

  Definition Loc_PI := valTyp_irrelevance.

  Definition BInit := {|
          currentPartition :=  defaultPage;
          memory:= @nil (paddr * value);
                      |}.
End IdModP.
\end{lstlisting} \vspace{4pt}

In addition to the memory state, the PIP monad manages undefined behaviour. However, we don't have error handling in the deep embedding. Therefore, we are going to use \textit{option} types to deal with undefined behaviour of the PIP monad. This will be further discussed in section \ref{limitations} p.\pageref{limitations}.

\section{1\st invariant and proof} 

\subsection{Invariant in the shallow embedding} \label{getFstInv}
This invariant concerns a function named \textit{getFstShadow}. We want to prove that if the necessary properties for the correct execution of this function are verified then any precondition on the state persists after its execution since this function doesn't change it. We also need to ascertain the validity of the returned value. It is defined as follows (\cite{PIP}, Invariants.v) :  
\begin{lstlisting}[caption = {getFstShadow invariant in the shallow embedding}, xleftmargin=-.02\textwidth,
xrightmargin=-.02\textwidth,mathescape=true]
Lemma getFstShadow (partition : page) (P : state $\rightarrow$ Prop) :
{{fun s $\Rightarrow$ P s  $\bigwedge$ partitionDescriptorEntry s $\bigwedge$ 
	   partition $\in$ (getPartitions multiplexer s)  }} 
Internal.getFstShadow partition
{{fun (sh1 : page) (s : state) $\Rightarrow$ P s $\bigwedge$ 
	   nextEntryIsPP partition sh1idx sh1 s }}.
\end{lstlisting}
where :
\begin{itemize}
	\item \textbf{getFstShadow :} is a function that \textbf{returns the physical page of the first shadow} for a given partition. The index of the virtual address of the first shadow, called \textit{sh1idx} as shown in annex \ref{stateFile} p.\pageref{stateFile}, is predefined in PIP as the 4\rth index of a partition. Furthermore, we know that the virtual address and the physical address of any page are consecutive. Therefore, we only need to fetch the predefined index of the first shadow, calculate its successor then read the corresponding page in the given partition. It is defined as follows (\cite{PIP}, Internal.v) :
\begin{lstlisting}[caption = {getFstShadow function in the shallow embedding},label={getFstShallow}]
Definition getFstShadow (partition : page):=
  perform idx := getSh1idx in
  perform idxsucc := MALInternal.Index.succ idx in
  readPhysical partition idxsucc.
\end{lstlisting} 
\vspace{4pt}
	\item \textbf{P :} is the propagated property on the state;
	\item \textbf{getPartitions :}  is a function that returns the list of all sub-partitions of a given partition. In our case, since we give it the multiplexer partition which is the root partition, it returns all the partitions in the memory. This function is used to verify that the partition we give to the \textit{getFstShadow} function is valid by checking its presence in the partition tree;
	\item \textbf{nextEntryIsPP :}  returns \textit{True} if the entry at position successor of the given index in the given table is a physical page and is equal to another given page. It is defined as follows (\cite{PIP}, StateLib.v) : 
\begin{lstlisting}[caption = {nextEntryIsPP property},mathescape=true, xleftmargin=-.1\textwidth, xrightmargin=-.05\textwidth,label={nextEnt}]
Definition nextEntryIsPP table idxroot tableroot s : Prop:= 
match Index.succ idxroot with 
 | Some idxsucc => 
  match lookup table idxsucc (memory s) beqPage beqIndex with 
   | Some (PP table) => tableroot = table
   |_ => False 
  end
 | _ => False 
end.
\end{lstlisting} 
	\item \textbf{partitionDescriptorEntry :}  defines some properties of the partition descriptor. All the predefined indexes in the file \textit{PIPstate.v}, shown in annex \ref{stateFile} p.\pageref{stateFile}, should be less than the table size minus one and contain virtual addresses. This is verified by the \textit{isVA} property which returns \textit{True} if the entry at the position of the given index in the given table is a virtual address and is equal to a given value. The successors of these indexes contain physical pages which should not be equal to the default page. This is verified by the \textit{nextEntryIsPP} property. The \textit{partitionDescriptorEntry} property is defined as follows (\cite{PIP}, Consistency.v) :
\begin{lstlisting}[caption={partitionDescriptorEntry property},mathescape=true, xleftmargin=-.05\textwidth,label={descrip}]
Definition partitionDescriptorEntry s := 
$\forall$ (partition: page),  
 partition $\in$ (getPartitions multiplexer s) $\rightarrow$ 
 $\forall$ (idxroot : index), 
  (idxroot = PDidx $\vee$ idxroot = sh1idx $\vee$ 
   idxroot = sh2idx $\vee$ idxroot = sh3idx $\vee$ 
   idxroot = PPRidx $\vee$ idxroot = PRidx) $\rightarrow$
  idxroot < tableSize - 1 $\wedge$  isVA partition idxroot s $\wedge$  
  $\exists$ entry, nextEntryIsPP partition idxroot entry s $\wedge$  
           entry $\neq$ defaultPage.
\end{lstlisting} 
\vspace{4pt}	
\end{itemize}
In the next sections we will rewrite the \textit{getFstShadow} function as well as adapt these properties in order to prove this invariant in the deep embedding.


\subsection{Modelling the \textit{getFstShadow} function}
We worked on several possible definitions in the deep embedding for the \textit{getFstShadow} function, defined in script \ref{getFstShallow} p.\pageref{getFstShallow} taking into account the limitations of the deep embedding especially in dealing with inductive data types as it doesn’t provide us with a pattern matching construct.

\subsubsection{getSh1idx function} 
First, let's define \textit{getSh1idx} which returns the value of \textit{sh1idx}. In the deep embedding, we defined it as a deep index value of the predefined first shadow index :
\begin{lstlisting}[caption = {getSh1idx definition  in the deep embedding},xleftmargin=.02\textwidth,
xrightmargin=.02\textwidth]
Definition getSh1idx : Exp := Val (cst index sh1idx).
\end{lstlisting} 
\subsubsection{Index successor function}
Next, we need to implement the index successor function in the deep embedding. An index value has to be less then the preset table size. This property should be verified before calculating the successor. This function is defined as follows in the shallow embedding (\cite{PIP}, MALInternal.v) :
\begin{lstlisting}[caption = {Index successor function in the shallow embedding},xleftmargin=.04\textwidth,
xrightmargin=.04\textwidth,label={indexShal}]
Program Definition succ (n : index) : LLI index :=
 let isucc := n+1 in
 if (lt_dec isucc tableSize)
 then ret (Build_index isucc _)
 else  undefined 28.
\end{lstlisting} \vspace{4pt}
Although this function is defined in the hardware model, we chose to model it as part of our experimentation with the deep embedding. \textbf{Our approach is to rewrite this function in the deep embedding while leaving shallow bits that we progressively replace with deep definitions in order to make the shift from shallow proofs to deep ones gradual and modular}. First, we rewrote this function so that we could use it in a \textit{Modify} construct replacing the output type by \textit{option index}. We used the index constructor \textit{CIndex} to build the new index. The new shallow version is defined as follows : \pagebreak
\begin{lstlisting}[caption={Rewritten shallow index successor function},xleftmargin=-.01\textwidth,
xrightmargin=-.01\textwidth,label={succInt}]
Definition succIndexInternal (idx:index) : option index :=
 let (i,_) := idx in 
 if lt_dec i tableSize 
 then Some (CIndex (i+1)) 
 else None.
\end{lstlisting} \vspace{4pt}
Thus, the first version of the index successor function, called \textit{Succ}, is defined as a \textit{Modify} construct that uses a generic effect, called xf\_succ, of input type \textit{index} and output type \textit{option index}, which calls the rewritten shallow function \textit{succIndexInternal}. \textit{Succ} is parametrised by the name of the input index variable which will be evaluated in the variable environment : 
\begin{lstlisting}[caption = {Definition of Succ},xleftmargin=-.02\textwidth,
xrightmargin=-.02\textwidth, mathescape=true,label={SuccFn}]
Instance VT_index : ValTyp index.
Instance VT_option_index : ValTyp (option index).

Definition xf_succ : XFun index (option index) := {|
  b_mod := fun s (idx:index) $\Rightarrow$  (s, succIndexInternal idx)
|}.

Definition Succ (x:Id) : Exp :=
  Modify index (option index) VT_index VT_option_index 
  	            xf_succ (Var x).
\end{lstlisting} \vspace{4pt}

The second version of the successor function, called \textit{SuccD}, is different from the former one. In this version we don't want to call the shallow function \textit{succIndexInternal}. Instead, we are trying to devise a comparatively deeper definition of successor where the conditional structure is replaced by the deep construct \textit{IfThenElse} and the assignments are defined using the \textit{BindS} construct. The new version is defined as follows : 
\begin{lstlisting}[caption = {Definition of SuccD},label={SuccD}]
Definition SuccD (x:Id) :Exp :=
BindS "i" (prj1 x) 
          (IfThenElse (LtDec "i" tableSize) 
                      (Apply SomeCindexQF
                             (PS[SuccR "i"])
                      ) 
                      (Val(cst (option index) None))
          ).
\end{lstlisting} \vspace{4pt}
where \textit{prj1} is a projection of the first value of an index record which corresponds to the actual value of the index, \textit{LtDec} is the definition of the comparison function using its shallow version, \textit{SomeCindexQF} is a quasi-function that lifts a natural number to an \textit{option index} typed value using the shallow constructors \textit{Cindex} and \textit{Some} successively and \textit{SuccR} is a function that calculates the successor of a natural number. It is important to note that \textit{SomeCindex} is defined as a \textit{Modify} construct using a generic effect instead of a pure deep function since the deep embedding doesn’t provide a pattern matching construct to deal with such cases. Their formal definitions in Coq are as follows :   
\begin{lstlisting}[caption = {Functions called in SuccD} ,xleftmargin=-.04\textwidth,
xrightmargin=-.04\textwidth,mathescape=true]
(* projection function *)
Definition xf_prj1 : XFun index nat := {|
   b_mod := fun s (idx:index) => (s,let (i,_) := idx in i)
|}.
Definition prj1 (x:Id) : Exp :=
  Modify index nat VT_index VT_nat xf_prj1 (Var x). 
  
(* comparision function *)
Definition xf_LtDec (n: nat) : XFun nat bool := {|
   b_mod := fun s i $\Rightarrow$ (s,if lt_dec i n then true else false)
|}.
Definition LtDec (x:Id) (n:nat): Exp :=
  Modify nat bool VT_nat VT_bool (xf_LtDec n) (Var x). 

(* lifting funtion *)
Definition xf_SomeCindex : XFun nat (option index) := {|
   b_mod := fun s i $\Rightarrow$ (s,Some (CIndex i))
|}.
Definition SomeCindex (x:Id) : Exp :=
  Modify nat (option index) VT_nat VT_option_index  
  	      xf_SomeCindex (Var x).
Definition SomeCindexQF := QF 
(FC emptyE [("i",Nat)] (SomeCindex "i") 
    (Val (cst (option index) None)) "SomeCindex" 0).

(* successor function for natural numbers *)
Definition xf_SuccD : XFun nat nat := {|
   b_mod := fun s i => (s,S i)
|}.
Definition SuccR (x:Id) : Exp :=
  Modify nat nat VT_nat VT_nat xf_SuccD (Var x).
\end{lstlisting} \vspace{4pt} 

The last version calls a recursive function \textit{plusR} that calculates the sum of two natural numbers. More precisely, we replace the call of \textit{SuccR} in the former definition with \textit{plusR 1} which adds one to its given parameter. \textit{plusR} and the new successor function, called \textit{SuccRec}, are defined as follows : 
\begin{lstlisting}[caption = {Definition of PlusR} ,xleftmargin=-.04\textwidth,
xrightmargin=-.04\textwidth, mathescape=true]
Definition plusR' (f: Id) (x:Id) : Exp :=
      Apply (FVar f) (PS [VLift (Var x)]). 
Definition plusR (n:nat) := QF 
(FC emptyE [("i",Nat)] (VLift(Var "i")) 
    (BindS "p" (plusR' "plusR" "i") (SuccR "p")) "plusR" n).
\end{lstlisting}  
 
\begin{lstlisting}[caption = {Definition of SuccRec} ,xleftmargin=-.04\textwidth,
xrightmargin=-.04\textwidth, mathescape=true,label={SuccRec}]
Definition SuccRec (x:Id) :Exp :=
BindS "i" (prj1 x) 
          (IfThenElse (LtDec "i" tableSize) 
                      (Apply SomeCindexQF 
                             (PS[Apply (plusR 1) 
                                       (PS[VLift(Var "i")])])
                      ) 
                      (Val(cst (option index) None))
          ).
\end{lstlisting} 
\subsubsection{readPhysical function} 
Now, we need to define the function that will read the physical page in the given index. This function, called \textit{readPhysical} in the shallow embedding,  uses the predefined lookup function that returns the value mapped to the address-index pair we give it. As shown in script \ref{ReadPhy} (\cite{PIP}, MAL.v), \textit{readPhysical} checks whether the read page is actually a physical page by performing a match on the returned entry. \textit{beqPage} and \textit{beqIndex} are comparison functions respectively for pages and indexes. 
\begin{lstlisting}[caption = {readPhysical function in the shallow embedding},xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth ,label={ReadPhy},mathescape=true]
Definition readPhysical (paddr: page) (idx: index) : LLI page:=
 perform s := get in
 let entry := lookup paddr idx s.(memory) beqPage beqIndex in
 match entry with
  | Some (PP a) $\Rightarrow$ ret a
  | Some _ $\Rightarrow$ undefined 5
  | None $\Rightarrow$ undefined 4
 end.
\end{lstlisting} \pagebreak
To implement this function in the deep embedding, we first copied all the predefined association list functions in a file we named \textit{Lib.v}, as shown in annex \ref{LibFile} p.\pageref{LibFile}. We then rewrote this function so that we could use it in a \textit{Modify} construct replacing the output type by \textit{option page} as follows :
\begin{lstlisting}[caption = {Rewritten shallow readPhysical function},xleftmargin=-.02\textwidth,
xrightmargin=-.02\textwidth,mathescape=true]
Definition readPhysicalInternal p i memory :option page := 
 match (lookup p i memory beqPage beqIndex) with
  | Some (PP a) $\Rightarrow$ Some a
  | _ $\Rightarrow$ None
 end.
\end{lstlisting} \vspace{4pt}
The function is called \textit{ReadPhysical} in the deep embedding and is parametrised by the name of the \textit{option index} typed variable. \textit{ReadPhysical} performs a match on its input to verify that it's a valid index then naturally calls \textit{readPhysicalInternal}. It is defined as follows : 
\begin{lstlisting}[caption = {Definition of ReadPhysical} ,xleftmargin=-.085\textwidth,
xrightmargin=-.085\textwidth,mathescape=true, label={readPhyD}]
Instance VT_option_page : ValTyp (option page).

Definition xf_read (p: page): XFun (option index) (option page) := 
{| b_mod := fun s oi => (s,match oi with 
   	|None => None 
   	|Some i => readPhysicalInternal p i (memory s) end) |}.

Definition ReadPhysical (p:page) (x:Id) : Exp :=
  Modify (option index) (option page) 
         VT_option_index VT_option_page 
         (xf_read p) (Var x).
\end{lstlisting} \vspace{4pt}

Using these definitions we are going to define three versions of \textit{getFstShadow} in the deep embedding, each calling a different version of the index successor function. These functions are named \textit{getFstShadowBind}, \textit{getFstShadowBindDeep} and \textit{getFstShadowBindDeepRec} and respectively call Succ, SuccD and SuccRec. Since their definitions are same, we will only give the definition of \textit{getFstShadowBind} :

\begin{lstlisting}[caption = {Definition of getFstShadowBind} ,mathescape=true,xleftmargin=.06\textwidth,
xrightmargin=.06\textwidth,label={getFstBind}]
Definition getFstShadowBind (p:page) : Exp :=
 BindS "x" getSh1idx 
           (BindS "y" (Succ "x") 
                      (ReadPhysical p "y")
           ).
\end{lstlisting}
 
\subsection{Invariant in the deep embedding}
To model this invariant in the deep embedding we will use the Hoare triple we defined in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec}. However, we need to adapt some of the properties mentioned in section \ref{getFstInv} p.\pageref{getFstInv}. In particular, the property \textit{nextEntryIsPP}, defined in script \ref{nextEnt} p.\pageref{nextEnt}, needs to be parametrised by the resulting deep value. So the page we need to compare is of type \textit{Value} instead of \textit{page}. the comparison between the fetched and given value now becomes a comparison between two deep values and not shallow ones. Also, to calculate the successor of the given index we use the rewritten successor function \textit{succIndexInternal}, defined in script \ref{succInt} p.\pageref{succInt}. Also, when we call this property in \textit{partitionDescriptorEntry}, defined in script \ref{descrip} p.\pageref{descrip}, we need to lift the page to an \textit{option page} typed deep value. This property is now defined as follows : 
\begin{lstlisting}[caption = {Rewritten nextEntryIsPP property} ,mathescape=true,xleftmargin=-.08\textwidth,
xrightmargin=-.08\textwidth]
Definition nextEntryIsPP (p:page) (idx:index) (p':Value) (s:W) := 
match succIndexInternal idx with 
 | Some i => 
  match lookup p i (memory s) beqPage beqIndex with 
   | Some (PP table) => p' = cst (option page) (Some table)
   |_ => False 
  end
 | _ => False 
end.
\end{lstlisting} \vspace{4pt}

Finally, we can write the deep Hoare triple which is not only parametrised by the partition and the propagated property but also by the function environment as well as the variable environment we want to evaluate the \textit{getFstShadow} function in. It is formally defined in Coq as follows : 
\begin{lstlisting}[caption = {getFstShadow invariant definition} ,mathescape=true,xleftmargin=-.04\textwidth,
xrightmargin=-.04\textwidth]
Lemma getFstShadowBindH (partition : page) (P : W -> Prop) 
	                (fenv: funEnv) (env: valEnv) :
{{fun s $\Rightarrow$ P s $\wedge$ partitionDescriptorEntry s $\wedge$ 
           partition $\in$ (getPartitions multiplexer s)}}
fenv >> env >> (getFstShadowBind partition) 
{{fun sh1 s $\Rightarrow$ P s $\wedge$ nextEntryIsPP partition sh1idx sh1 s}}.
\end{lstlisting} \vspace{4pt}
Naturally, since we defined three \textit{getFstShadow} functions, each calling a different version of the deep index successor function, we only need to specify the name of version of \textit{getFstShadow} we want to  call. In this case we are calling \textit{getFstShadowBind} defined in script \ref{getFstBind} p.\pageref{getFstBind}.


\subsection{Invariant proof} \label{proof}
\begin{lstlisting}[caption = {Proof of the getFstShadow invariant},xleftmargin=-.08\textwidth,
xrightmargin=-.08\textwidth,mathescape=true,numbers=left]
Proof.
unfold getFstShadowBind. (* or other called function *)
eapply BindS_VHTT1.
eapply getSh1idxWp.
simpl; intros.
eapply BindS_VHTT1.
eapply weakenEval.
eapply succWp. (* or other Lemma for called function *)
simpl; intros; intuition.
instantiate (1:=(fun s => P s $\wedge$ partitionDescriptorEntry s $\wedge$ 
                  partition $\in$ (getPartitions multiplexer s))).
simpl. intuition. instantiate (1:=sh1idx).
eapply H0 in H3.
specialize H3 with sh1idx.
eapply H3. auto. auto.
simpl; intros.
eapply weakenEval.
eapply readPhysicalW.
simpl;intros; intuition.
destruct H3. exists x.
unfold partitionDescriptorEntry in H1.
apply H1 with partition sh1idx in H4.
clear H1; intuition.
destruct H5. exists x0. intuition.
unfold nextEntryIsPP in H4.
unfold readPhysicalInternal; subst.
inversion H2.
repeat apply inj_pair2 in H3.
unfold nextEntryIsPP in H5.
rewrite H3 in H5.
destruct (lookup partition x (memory s) beqPage beqIndex).
unfold cst in H5.
destruct v0;try contradiction.
apply inj_pairT2 in H5.
inversion H5. auto.
unfold isVA in H4.
destruct (lookup partition sh1idx (memory s) beqPage beqIndex) 
in H2; try contradiction. auto.
Qed.
\end{lstlisting} 
As shown in the previous script, we start the proof by evaluating the first assignment using the assignment rule \textit{BindS\_VHTT1} defined in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec}. This implies evaluating \textit{getSh1idx} and mapping its resulting value to \textit{x} in the variable environment then evaluating the rest of the function in this updated environment. To evaluate \textit{getSh1idx}, we use a lemma that we have proven called \textit{getSh1idxWp}. This lemma also propagates any property on the state.
\begin{lstlisting}[caption = {getSh1idxWp lemma definition and proof},xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth,mathescape=true]
Lemma getSh1idxW (P: Value -> W -> Prop) 
	         (fenv: funEnv) (env: valEnv) :
  {{wp P fenv env getSh1idx}} fenv >> env >> getSh1idx {{P}}.
Proof.
(* the weakest precondition is a precondition *)
apply wpIsPrecondition.
Qed.

Lemma getSh1idxWp P fenv env :
{{P}} fenv >> env >> getSh1idx 
{{fun (idxSh1 : Value) (s : state) $\Rightarrow$ P s  
	    $\wedge$ idxSh1 = cst index sh1idx }}.
Proof.
eapply weakenEval. (* weakening precondition *)
eapply getSh1idxW.
intros. 
unfold wp.
intros.
unfold getSh1idx in X.
inversion X;subst.
auto.
inversion X0.
Qed. 
\end{lstlisting} \vspace{4pt}

In script \ref{getFstInv}, two lines change in the the proof for the different \textit{getFstShadow} functions. Indeed, in the first line, we need to adapt the name of the unfolded function according to the one we call in the Hoare triple definition. Later, we call the assignment rule again and we need to evaluate the successor function which is different in each \textit{getFstShadow} definition. Therefore, we need to define a lemma for each version and call it when needed in the 8\rth line. The version which corresponds to our case is defined and proven as follows : \pagebreak
\begin{lstlisting}[caption = {succWp lemma definition and proof},numbers=left, xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth,mathescape=true,label={succWp}]
Lemma succWp (x:Id) (v:Value) P (fenv: funEnv) (env: valEnv) :
 $\forall$ (idx:index), 
 {{fun s $\Rightarrow$ P s $\wedge$ idx < tableSize - 1 $\wedge$ v=cst index idx}} 
  fenv >> (x,v)::env >> Succ x (* or other successor function *) 
 {{fun (idxsuc : Value) (s : state) $\Rightarrow$ P s  $\wedge$
	 idxsuc = cst (option index) (succIndexInternal idx) $\wedge$
	 $\exists$ i, idxsuc = cst (option index) (Some i)}}.
Proof.
intros.
eapply weakenEval.
eapply succW. (* or other lemma for called function *)
intros.
simpl.
split.
instantiate (1:=idx).  
intuition.
intros.
intuition.
destruct idx.
exists (CIndex (i + 1)).
f_equal.
unfold succIndexInternal.
case_eq (lt_dec i tableSize).
intros.
auto.
intros.
contradiction.
Qed.
\end{lstlisting} \vspace{4pt}
This lemma proves that we get a valid index after executing successor since the precondition assures its correct execution. Only the 11\rth line of the proof changes according the the called successor function. The lemma defined in the 11\rth line proves that the resulting value of the execution of the successor function is equal the the value we get when we apply the shallow \textit{succIndexInternal} function to the same given index. The proof of this evaluation lemma is quite different between the various versions which is logical since evaluating a \textit{Modify} that calls the shallow \textit{succIndexInternal} function is different from evaluating all the deep constructs in the deep and recursive versions of the successor function. \\

The proof of the first lemma, called \textit{succW}, which evaluates the \textit{Succ} function defined in script \ref{SuccFn} p.\pageref{SuccFn}, goes naturally by inversion on the closure. It is defined and proven as follows :
\begin{lstlisting}[caption = {succW Lemma definition and proof}, xleftmargin=-.05\textwidth,
xrightmargin=-.05\textwidth,mathescape=true]
Lemma succW  (x : Id) (P: Value $\rightarrow$ W $\rightarrow$ Prop) (v:Value) 
	     (fenv: funEnv) (env: valEnv) :
$\forall$ (idx:index),
 {{fun s $\Rightarrow$ idx < (tableSize -1) $\wedge$ $\forall$  l : idx + 1 < tableSize, 
    P (cst (option index) (succIndexInternal idx)) s $\wedge$
    v = cst index idx }}  
  fenv >> (x,v)::env >> Succ x {{ P }}.
Proof.
intros.
unfold THoareTriple_Eval; intros; intuition.
destruct H1 as [H1 H1'].
omega.
inversion X;subst.
inversion X0;subst.
repeat apply inj_pair2 in H7;subst.
inversion X2;subst.
inversion X3;subst.
inversion H;subst.
destruct IdModP.IdEqDec in H3.
inversion H3;subst.
clear H3 e X3 H XF1.
inversion X1;subst.
inversion X3;subst.
repeat apply inj_pair2 in H7.
repeat apply inj_pair2 in H9. subst.
unfold b_exec,b_eval,xf_succ,b_mod in *.
simpl in *.
inversion X4;subst.
apply H1.
inversion X5.
inversion X5.
contradiction.
Qed.
\end{lstlisting} \vspace{4pt}

The proof of the second lemma, called \textit{succDW}, which evaluates the \textit{SuccD} function defined in script \ref{SuccD} p.\pageref{SuccD}, is quite longer than the previous one. Indeed, we need to proceed by inversion on the evaluation of every deep construct. This lemma is defined and proven in annex \ref{getFstFile} p.\pageref{getFstFile}.  \\  

For The third lemma, which evaluates the \textit{SuccRec} function defined in script \ref{SuccRec} p.\pageref{SuccRec}, we did two different proofs : one using only inversions, called \textit{succRecWByInversion}, and the other using the Hoare triple rules shown in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec}, called \textit{succRecW}. The former takes about 480 lines to prove while the latter takes approximatively 350 lines wich amounts to 130 lines less. Furthermore, the proof of the lemma \textit{succRecW}, which uses Hoare triple rules seems more organised since we deal with the poof of each instruction at a time and not the function as a whole.\\

Finally, all what is left in the main proof is to evaluate the last function \textit{ReadPhysical} and prove the implication between properties. To that end, we defined the following lemma, called \textit{readPhysicalW} and proven in annex \ref{getFstFile} p.\pageref{getFstFile}, as follows : 
\begin{lstlisting}[caption = {readPhysicalW Lemma definition and proof}, xleftmargin=-.08\textwidth,
xrightmargin=-.08\textwidth,mathescape=true]
Lemma readPhysicalW (y:Id) table (v:Value) 
	(P' : Value $\rightarrow$ W $\rightarrow$ Prop) (fenv: funEnv) (env: valEnv) :
 {{fun s $\Rightarrow$  $\exists$ idxsucc p1, v = cst (option index) (Some idxsucc)
   $\wedge$ readPhysicalInternal table idxsucc (memory s) = Some p1 
   $\wedge$ P' (cst (option page) (Some p1)) s}} 
 fenv >> (y,v)::env >> ReadPhysical table y {{P'}}.
\end{lstlisting} \vspace{4pt}

\subsection{The Apply approach}
For this approach, we chose to replace assignments in the \textit{getFstShadow} function with function applications. For simplicity’s sake,  We chose to use the first version of the index successor function called \textit{Succ} defined in script \ref{SuccFn} p.\pageref{SuccFn}. However, considering our modular approach for its definition, we could easily replace it with its other versions and use the lemmas we devised for them in the new proof. To the \textit{Apply} construct, we need to lift both \textit{SuccD} and \textit{readPhysical}, defined in script \ref{readPhyD} p.\pageref{readPhyD}, to quasi-functions as follows :
\begin{lstlisting}[caption = {Lifting Succ and  readPhysical to quasi-functions}, mathescape=true]
Definition SuccQF := QF (FC emptyE [("y",indexType)] 
 (Succ "y") (Val (cst (option index) None)) "Succ" 0).

Definition ReadPhysicalQF (p:page) := QF (FC 
 emptyE [("x",optionIndexType)] (ReadPhysical p "x") 
 (Val (cst (option page) None)) "ReadPhysical" 0).
\end{lstlisting} \vspace{4pt}
The new version of the \textit{getFstShadow} function, called \textit{getFstShadowApply} is defined as follows :
\begin{lstlisting}[caption = {getFstShadowApply definition}, mathescape=true]
Definition getFstShadowApply (p:page) :Exp :=
Apply (ReadPhysicalQF p) (PS [
                         Apply SuccQF (PS [getSh1idx])
                      ]). 
\end{lstlisting} \vspace{4pt}

For the proof, we didn't need to define any additional lemma about the intermediate functions. This is due to the use of the Hoare triple rules. The new invariant, called \textit{getFstShadowApplyH'}, is defined and proven in annex \ref{getFstFile} p.\pageref{getFstFile}.

\section{2\nd invariant and proof} \label{writeInvSec}
This new invariant is about a function called \textit{writeVirtual} that writes a virtual address in the memory. We want to prove that this function verifies all of PIP's properties which include memory isolation, vertical sharing, kernel data isolation and consistency properties, mentioned in section \ref{properties} p.\pageref{properties}. In the shallow embedding, \textit{writeVirtual} is defined as follows (\cite{PIP}, MAL.v) : 
\begin{lstlisting}[caption = {writeVirtual function in the shallow embedding}, xleftmargin=-.05\textwidth,
xrightmargin=-.05\textwidth,mathescape=true, label={writeS}]
Definition writeVirtual (paddr: page) (idx: index) 
		        (va: vaddr) :LLI unit :=
 modify (fun s $\Rightarrow$ {| 
  currentPartition := s.(currentPartition);
  memory := add paddr idx (VA va) s.(memory) beqPage beqIndex 
 |}).
\end{lstlisting} \vspace{4pt}
First, we rewrote this function to act directly on the state as follows :
\begin{lstlisting}[caption = {Rewritten shallow writeVirtual function}, xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth,mathescape=true]
Definition writeVirtualInternal (p:page) (i:index) (v:vaddr) :=
 fun s $\Rightarrow$ {| 
  currentPartition := s.(currentPartition);
  memory := add p i (VA v) s.(memory) beqPage beqIndex |}.  
\end{lstlisting} \vspace{4pt}
It is clear that the \textit{writeVirtual} function is purely a generic effect. Its output value is irrelevant so its output type is declared as \textit{unit}. We only need to call the \textit{writeVirtualInternal} function in the generic effect which will be used the \textit{Modify} construct to define the deep version, called \textit{WriteVirtual}, as follows : 
\begin{lstlisting}[caption = {WriteVirtual definition}, xleftmargin=-.07\textwidth,
xrightmargin=-.07\textwidth,mathescape=true, label={writeD}]
Definition xf_writeVirtual (p: page) (i: index) (v: vaddr) 
	                      : XFun unit unit := 
 {| b_mod := fun s _ $\Rightarrow$ (writeVirtualInternal p i v s,tt) |}.

Definition WriteVirtual (p: page) (i: index) (v: vaddr) : Exp :=
  Modify unit unit VT_unit VT_unit (xf_writeVirtual p i v) 
  	           (QV (cst unit tt)).    
\end{lstlisting} \vspace{4pt}

To check that our implementation is correct, we first focused on a simpler invariant which asserts a relevant property of the \textit{writeVirtual} function. This property is included in the postcondition of the main invariant we want to prove. Indeed, when we write a virtual address \textit{v} in the page \textit{p} in the memory, at a certain position, and when we read the page \textit{p} immediately after, at the exact same position, we should get the same value \textit{v}. This Lemma is defined and proven as follows :
\begin{lstlisting}[caption = {writeVirtualInvNewProp invariant definition}, xleftmargin=-.05\textwidth,
xrightmargin=-.05\textwidth,mathescape=true, label={writeNew}]
Lemma writeVirtualInvNewProp (p : page) (i:index) (v:vaddr) 
	                     (fenv: funEnv) (env: valEnv) :
 {{fun _ $\Rightarrow$ True}}
  fenv >> env >> WriteVirtual p i v
 {{fun _ s $\Rightarrow$ readVirtualInternal p i s.(memory) =  Some v}}.
Proof.
unfold THoareTriple_Eval; intros.
clear H k3 t k2 k1 tenv ftenv.
inversion X;subst.
inversion X0;subst.
repeat apply inj_pair2 in H5.
apply inj_pair2 in H7.
subst.
unfold b_eval, b_exec, xf_writeVirtual, b_mod in *.
simpl in *.
inversion X1;subst.
unfold writeVirtualInternal;simpl.
unfold add.
unfold readVirtualInternal;simpl.
specialize beqPairsTrue with p i p i.
intros;intuition.
rewrite H. reflexivity.
inversion X2.
inversion X2.
Qed.    
\end{lstlisting} \vspace{4pt}

To define the main invariant, we copied all the definitions of PIP's propagated properties as well as PIP's internal and dependant-type lemmas respectively in the files \textit{Pip\_Prop.v} \textit{Pip\_InternalLemmas.v} and \textit{Pip\_DependentType-\linebreak Lemmas.v}. Then we defined and proved the following lemma about the  \textit{writeVirtual} function :
\begin{lstlisting}[caption = {writeVirtualWp lemma definition and proof}, xleftmargin=-.09\textwidth,
xrightmargin=-.09\textwidth,mathescape=true]
Lemma writeVirtualWp (p: page) (idx: index) (vad: vaddr) 
      (P: Value $\rightarrow$ state $\rightarrow$ Prop) (fenv: funEnv) (env: valEnv) :
 {{fun  s $\Rightarrow$ P (cst unit tt) {| 
   currentPartition := currentPartition s;
   memory := add p idx (VA vad) (memory s) beqPage beqIndex |} }} 
 fenv >> env >> WriteVirtual table idx addr  {{P}}.
Proof.
unfold THoareTriple_Eval.
intros. 
inversion X;subst.
inversion X0;subst.
repeat apply inj_pair2 in H6.
repeat apply inj_pair2 in H8.
subst.
unfold xf_writeVirtual, b_eval, b_exec, b_mod in *.
simpl in *.
inversion X1;subst.
auto.
inversion X2.
inversion X2.
Qed.
\end{lstlisting} \vspace{4pt}
Finally, we use the lemma above to prove the main invariant. As expected, the deep proof is practically identical to the shallow proof since we're weakening the Hoare triple first to use the 
\textit{writeVirtualWp} lemma then we're proving a direct implication between properties on the state. The main invariant, called \textit{writeVirtualInv}, is defined and proven in annex \ref{writeFile} p.\pageref{writeFile}. 

\section{3\rd invariant and proof} \label{proof3}
The third invariant is about a recursive function of PIP called \textit{initVAddrTable} that initializes virtual addresses of a given table to the default value \textit{defaultVAddr} defined in annex \ref{stateFile} p.\pageref{stateFile}. This function is defined as follows in the shallow embedding (\cite{PIP}, Internal.v) : 
\begin{lstlisting}[caption = {initVAddrTable in the shallow embedding}, xleftmargin=-.02\textwidth,
xrightmargin=-.02\textwidth,mathescape=true]
Fixpoint initVAddrTableAux timeout shadow2 idx :=
  match timeout with
  | 0 $\Rightarrow$ ret tt
  | S timeout1 $\Rightarrow$
    perform maxindex := getMaxIndex in
    perform res := MALInternal.Index.ltb idx maxindex in
    if (res)
    then
      perform defaultVAddr := getDefaultVAddr in
      writeVirtual shadow2 idx defaultVAddr;;
      perform nextIdx :=  MALInternal.Index.succ idx in
      initVAddrTableAux timeout1 shadow2 nextIdx
    else  
      perform defaultVAddr := getDefaultVAddr in
      writeVirtual shadow2 idx defaultVAddr
  end.

(* Specifies the timeout of  initVAddrTableAux *) 
Definition initVAddrTable sh2 n :=
  initVAddrTableAux tableSize sh2 n.
\end{lstlisting} \vspace{4pt}
where :
\begin{itemize}
	\item\textbf{getMaxIndex :} returns the value of the maximum index which is equal to the table size minus one, knowing that the table size is different than 0. We wrote the following simplified definition to use in the deep embedding : 
\begin{lstlisting}[caption = {maxIndex definition}, xleftmargin=.01\textwidth,
xrightmargin=.01\textwidth,mathescape=true]
Axiom tableSizeNotZero : tableSize <> 0.
Definition maxIndex : index := CIndex(tableSize-1). 
\end{lstlisting} \vspace{4pt}
	\item \textbf{succ :} is the index successor function defined in script \ref{indexShal} p.\pageref{indexShal}. We will replace it with its deep implementation \textit{SuccD} defined in script \ref{SuccD} p.\pageref{SuccD};
	\item \textbf{ltb :} is a comparison function for indexes similar to the mathematical comparison operator $<$ for natural numbers. In the deep embedding, we will define this function by calling its shallow version in as a generic effect as follows :
\begin{lstlisting}[caption = {LtLtb definition}, xleftmargin=-.05\textwidth,
xrightmargin=-.01\textwidth,mathescape=true]
Definition xf_Ltb (i:index) : XFun index bool := 
 {| b_mod := fun s idx => (s,Index.ltb idx i) |}.

Definition LtLtb (x:Id) (i:index) : Exp :=
  Modify index bool VT_index VT_bool (xf_Ltb i) (Var x). 
\end{lstlisting} 	
	\item \textbf{writeVirtual :} is the function, defined in script \ref{writeS} p.\pageref{writeS}, that writes a virtual address in the memory. We couldn't use its previous implementation, called \textit{WriteVirtual}, defined in script \ref{writeD} p\pageref{writeD} because we're not working directly with the value of the given index but with a variable which we need to evaluate in the variable environment. The new version of this function called \textit{writeVirtual'} is defined as follows :
\begin{lstlisting}[caption = {writeVirtual new definition}, xleftmargin=-.15\textwidth,
xrightmargin=-.11\textwidth,mathescape=true]
Definition xf_writeVirtual' (p:page) (v:vaddr) :XFun index unit:= 
  {| b_mod := fun s i => (writeVirtualInternal p i v s,tt) |}.
 
Definition WriteVirtual' (p:page) (i:Id) (v:vaddr) :Exp :=
 Modify index unit VT_index VT_unit (xf_writeVirtual' p v) (Var i).
\end{lstlisting} 
\end{itemize}
We also need to define \textit{ExtractIndex} which extracts an index from an \textit{option index} typed value by performing a pattern matching. This is only possible by using a generic effect as follows : 
\begin{lstlisting}[caption = {ExtractIndex definition}, xleftmargin=-.01\textwidth,
xrightmargin=-.01\textwidth,mathescape=true]
Definition xf_ExtractIndex : XFun (option index) index := 
{| b_mod := fun s idx => (s,match idx with 
	                     |Some i => i 
	                     |_ => index_d end) |}.
	                     
Definition ExtractIndex (x:Id):= 
  Modify (option index) index VT_option_index VT_index 
              xf_ExtractIndex (Var x).
\end{lstlisting} \vspace{4pt}
To simplify the proof and avoid repetition, we will place the instruction that calls \textit{WriteVirtual'} before the conditional structure. \textit{initVAddrTableAux} and \textit{initVAddrTable} are defined as follows : \pagebreak
\begin{lstlisting}[caption = {initVAddrTable definition in the deep embedding}, xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth,mathescape=true]
Definition initVAddrTableAux (f i: Id) (p:page) : Exp :=
BindN (WriteVirtual' p i defaultVAddr)
      (IfThenElse (LtLtb i maxIndex)
                  (BindS "y" (BindS "idx" (SuccD i) 
                                          (ExtractIndex "idx"))
                             (Apply (FVar f) 
                                    (PS [VLift(Var "y")])))
                  (Val (cst unit tt))). 
Definition initVAddrTable (p:page) (i:index) := 
Apply (QF (FC emptyE [("x",Index)] (Val (cst unit tt)) 
          (initVAddrTableAux "initVAddrTable" "x" p) 
          "initVAddrTable" tableSize) (PS[Val (cst index i)]). 
\end{lstlisting}	\vspace{4pt}

The invariant we want to prove, called \textit{initVAddrTableNewProperty}, is defined in script \ref{vaddInv}. The proof is done by induction on the bound. More precisely, we suppose that the Hoare triple is valid for the bound \textit{n} and we need to prove it's valid for \textit{S n}. We mainly used the Hoare triple rules defined in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec} to evaluate each deep construct to get to the next function application where n is the bound which we have as a hypothesis. The main difficulty was to get to the exact same expression as well as the same function and variable environments as we have in the hypothesis without unfolding the Hoare triple. Indeed, if we unfold the Hoare triple at some point earlier, we have to reason by inversion on large expressions and we may encounter some typing problems which makes the proof much more complicated. In order to break down the proof of the step case, we defined a new lemma about the successor function, called \textit{succWp'}, similar to the \textit{succWp} lemma defined in script \ref{succWp} p.\pageref{succWp}, in which we propagate the specification of the value added to the environment.  It is also important to note that, to prove \textit{succWp'}, we used \textit{succDW}, the evaluation lemma for the index successor function defined and proven in annex \ref{getFstFile} p.\pageref{getFstFile}, which reinforces the importance of our modular approach. \textit{succWp'} and the proof of the \textit{initVAddrTableNewProperty} lemma is detailed in annex \ref{initFile} p.\pageref{initFile}.
\begin{lstlisting}[caption = {initVAddrTableNewProperty invariant in the deep embedding}, xleftmargin=-.07\textwidth,
xrightmargin=-.07\textwidth,mathescape=true, label={vaddInv}]
Lemma initVAddrTableNewProperty table (curidx : index) 
                (fenv: funEnv) (env: valEnv) :
 {{ fun s $\Rightarrow$ ($\forall$ idx : index, idx < curidx $\rightarrow$ 
     (readVirtual table idx (memory s) = Some defaultVAddr) )}} 
  fenv >> env >> initVAddrTable table curidx 
 {{fun _ s $\Rightarrow$ $\forall$ idx, readVirtual table idx s.(memory) = 
 	             Some defaultVAddr }}. 
\end{lstlisting}	


\section{Observations}

\subsection{Deep vs shallow}
Specifying programs in the deep embedding has the great advantage of simplifying their syntactic manipulation. It also ensures a stricter structuring of program expressions. An interesting conjecture is whether this structure is reflected in the proofs. If we consider naive proofs mostly done by applying inversions, this is not the case. Such proofs can be really monotonous but overall they lack structure and readability since we deal with the program as a whole and not each instruction at a time like we do in the shallow proofs. However using the Hoare rules, shown in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec}, we could make proofs that compare favourably with the shallow ones in terms of structuring. Nevertheless, they become comparatively longer. Furthermore, proof specifications are generally more complex in the deep embedding as we need to worry about the specification of deep values among others. 

\subsubsection{Proof structuring}
\paragraph{Importance of Hoare triple rules} \label{HoareRules}
Throughout our experiments, the Hoare triple rules shown in section \ref{HoareDeepSec} p.\pageref{HoareDeepSec} have proven efficient at dealing with proofs in the deep embedding and this is due to many reasons :
\begin{itemize}
	\item They enable us to structurally decompose our proofs and deal with each instruction at a time which makes them well structured and legible. This is really important when dealing with large expressions and it is what made our modular approach possible.
	\item They enable us to construct shorter proofs as was the case with the \textit{succRecW} lemma, mentioned in section \ref{proof} p.\pageref{proof}, which was 130 lines less than its counterpart with inversions only. 
	\item They internally deal with well-typedness issues which simplifies further our proofs.
\end{itemize}

To summarise, Hoare triple rules make our proofs \textbf{simpler}, \textbf{shorter}, \textbf{more structured} and \textbf{legible}. That's why we strongly advise their use in deep proofs. \pagebreak

\subsubsection{Proof specifications}
\paragraph{Dealing with values in the deep embedding}
Values in the deep embedding encapsulate their shallow type and value. This has a big impact on deep proofs. Indeed, when we need to communicate a value to certain lemma, we would naturally parametrise the lemma by a \textit{Value} typed parameter as in lemma \textit{succWp}, defined in script \ref{succWp} p.\pageref{succWp}. In script \ref{succWpF}, we give a slightly different definition of this lemma in which we omit the value specification part in the precondition. Proving this lemma is impossible as we don't have any information about the deep value \textit{v}. Thus, we can't ascertain that it is \textit{index} typed as a deep value nor that its actual value is \textit{idx}. This differs from shallow proofs where we manipulate directly shallow typed values. Furthermore, this makes dealing with variable and function environments more complicated as we may have to propagate some values in the environments as we did with lemma \textit{succWp'} mentioned in section \ref{proof3} p.\pageref{proof3}.
\begin{lstlisting}[caption = {succWp false lemma definition},numbers=left, xleftmargin=-.06\textwidth,
xrightmargin=-.06\textwidth, mathescape=true,label={succWpF}]
Lemma succWp (x:Id) (v:Value) P (fenv: funEnv) (env: valEnv) :
 $\forall$ (idx:index), 
 {{fun s $\Rightarrow$ P s $\wedge$ idx < tableSize - 1}} 
  fenv >> (x,v)::env >> Succ x (* or other successor function *) 
 {{fun (idxsuc : Value) (s : state) $\Rightarrow$ P s  $\wedge$
	 idxsuc = cst (option index) (succIndexInternal idx) $\wedge$
	 $\exists$ i, idxsuc = cst (option index) (Some i)}}.
\end{lstlisting} \vspace{4pt}

\paragraph{Defining Shallow functions}
As there is a dimorphism  between the deep embedding and the logic, it is generally necessary to have both a shallow and deep version of each function. The shallow versions are mainly used in the predicates included in the preconditions and postconditions of Hoare triples. For example, we used the shallow \textit{succIndexInternal} function, defined in script \ref{succInt} p.\pageref{succInt}, in the postcondition of the \textit{succWp} lemma, defined in script \ref{succWp} \pageref{succWp}, to describe the resulting value of the deep index successor function. We also used it extensively in the proof of the third invariant \textit{initVAddrTableNewProperty}, detailed in annex \ref{initFile} p.\pageref{initFile}. This practically implies double amount of work for deep proofs compared to shallow ones where we use only shallow functions. A possible solution to this problem is to define a deep language with embedded logic \cite[Hoare Logic (Part II)]{SoftwareFoundation}. 

\subsection{Limitations imposed by DEC} \label{limitations}
DEC was intended to support translation and syntactic manipulation rather than modelling and verification. Therefore, some limitations were imposed by DEC on our verification proofs. Indeed, DEC doesn't provide explicit error handling. For this reason we used \textit{option} types. However, this use involved pattern matching. The deep embedding doesn't provide us with a pattern matching construct which makes dealing with inductive types rather intricate. Indeed, we have to deal with such types at the shallow level, which is possible using generic effects. This is clearly outlined in the definition of \textit{ReadPhysical} in script \ref{ReadPhy} p.\pageref{ReadPhy}, where we had to specify its input type as \textit{option index} instead of \textit{index} and perform the pattern matching before reading the state. In this case, we couldn't put the pattern matching in a separate generic effect since we would have had an issue with the \textit{None} case. Another problem which arises in this case is that we may need to duplicate functions if, for instance, we need to use a definition of \textit{ReadPhysical} without pattern matching. \textbf{An effective but challenging solution to this problem would be to devise a pattern matching construct in the deep embedding}. Nevertheless, it is important to note that, if we still intend for DEC to support only  translation and syntactic manipulation, the lack of a pattern matching construct will not be an issue since there aren't inductive types in C. 

\subsection{Further discussion about the deep implementation of shallow functions}
\textbf{What should we consider as a sufficiently deep implementation of a shallow function ?} The deep embedding of PIP is implemented in a way that allows extensibility of deep constructs using generic effects. This enabled us to model our functions gradually and temporarily resolved the problem of the lack of a pattern matching construct. But, it still remains quite risky since we can confuse deep with shallow. Indeed, the first version of the index successor function, called \textit{Succ} and defined in script \ref{SuccFn} p.\pageref{SuccFn}, is merely a call to the shallow function \textit{succIndexInternal}, defined in script \ref{succInt} p.\pageref{succInt}, that we wrapped in the \textit{Modify} construct. Although, \textit{Succ} was  defined as a deep expression, it is just the outer shell of the function that is deep but structurally it is shallow. \pagebreak

Then, we devised a comparatively deeper version of this function, called \textit{SuccD} and defined in script \ref{SuccD} p.\pageref{SuccD}. But, there are still shallow bits in this version like the index comparison function in particular. \textbf{In a completely deep definition of a shallow function, generic effects should be used just for essentially stateful operations.} However, the degree  to which we should deepen a shallow function is a choice that must be set according to our needs. For example, in our experiments we chose to omit completely deepening comparison functions. In the case of the PIP protokernel, deepening a shallow function depends on whether it is part of the algorithmic PIP code or the hardware model shown in figure \ref{design} p.\pageref{design}. 